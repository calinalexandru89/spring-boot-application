âœ… Spring Boot 3
âœ… HTTP & API development
âœ… Developer tools for maximum productivity
âœ… Robust error handling techniques
âœ… Databases & PostgreSQL
âœ… Spring Data JPA
âœ… Flyway for seamless database migrations
âœ… JDBC for efficient database communication
âœ… Testing strategies for robust, reliable code
âœ… Docker for containerization and deployment
âœ… AWS for cloud-based hosting and scaling
âœ… DevOps best practices for agile, collaborative development
âœ… javascript and React for front-end development
âœ… Spring Security 6 for secure, authenticated applications
âœ… Login/Registration systems for user management
âœ… TypeScript for type-safe, scalable code
âœ… Angular for powerful, responsive front-end interfaces
-----------------
Un bean este un obiect gestionat de containerul Spring
Asta inseamna ca Spring creeaza instanta clasei, o configureaza, o pastreaza in memorie si ti-o da
ori de cate ori ai nevoie de ea (prinm dependency injection)


Tomcat este un server web si un container de servlet-uri scrin in Java
Este cel care primeste request-urile HTTP, le proceseaza si trimite raspunsurile inapoi catre client(browser, app mobil, etc)
Este incorporat in SprintBoot
Tomcat asculta pe un port(implicit 8080)
Cand primeste un request(GET/salut), Tomcat il trimite la controller-ul potrivit din aplicatie
Controller-ul produce un raspuns, Tomcat il trimite clientului

in resources/application.yml se poate schimba:
portul cu comanda de mai jos:
server:
  port: 3000

co comanda de mai jos in acelasi fisier se poate opri serverul:
server:
  port: 3000

 spring:
  main:
    web-application-type: none
 //default el vine cu :servlet



Un servlet este o clasÄƒ Java care ruleazÄƒ pe un server de aplicaÈ›ii (precum Tomcat) È™i care primeÈ™te request-uri HTTP È™i trimite rÄƒspunsuri HTTP.
Pe scurt, un servlet este o bucatÄƒ de cod care È™tie sÄƒ rÄƒspundÄƒ la cereri de pe web.
Dar daca folosim springBoot stie el sa faca toate astea cu getMapping si RestController+

HTTP este limbajul standard de comunicare intre browser si server
Spune cum se cer si se trimit pagini web, imagini, fisiere sau date API

GET â†’ citeÈ™te
POST â†’ creeazÄƒ
PUT â†’ actualizeazÄƒ complet
DELETE â†’ È™terge
-----------------
// Maparea unui request HTTP GET catre metoda greet()
    // "/" inseamna radacina aplicatiei (ex: http://localhost:8080/) adica root cand executi direct, daca pui spre ex /greet atunci trebuie executat exact asa
    // Cand se acceseaza acest endpoint, se executa metoda si se trimite mesajul "Hello"
    @GetMapping("/greet")
    public GreetResponse greet(@RequestParam(value = "name", required = false) String name) {
        String greetMessage = name == null || name.isBlank() ? "Hello" : "Hello " + name;
        GreetResponse response = new GreetResponse(
                greetMessage,
                List.of("Java", "Golang", "JavaScript"),
                new Person("Alex", 36, 20_000)
        );
        return response;
    }

    record Person(String name, int age, double savings) {
    }

    // record - tip special de clasa pentru obiecte simple si imutabile
    // Genereaza automat constructor, gettere, equals, hascode si toString
    // Aici il folosim pentru a modela raspunsul API (JSON)
    record GreetResponse(
            String greet,
            List<String> favProgrammingLanguages,
            Person person
    ) {
    }
    ------------------------
    Clasa customer este un model/entity - reprezinta datele unui client - iar daca folosim JPA va fi o entitate mapata la tabel
    CustomerController - este un API/WebLayer - expune endpoint-uri HTTP(REST) - Primeste requestul, valideaze inputul si trimite mai departe la Service
    CustomerService - Business layer - contine logica de business(reguli, validari, tranzactii), nu stie de HTTP, doar de operatiile de domeniu si apeleaza DAO/Repository
    CustomerDao - Port/Repository-interfata - defineste operatiile de acces la datele pe care le vrei(contractul)
    CustomerDataAccessService - DAO implementation/Adapter - Implementarea concreta a lui DAO
    CustomerRepository este stratul de acces la date pentru entitatea Customer - ÃÈ›i oferÄƒ toate operaÈ›iile CRUD È™i query-uri simple direct, fÄƒrÄƒ cod suplimentar.

    Cum se leaga intre ele, fluxul unei cereri:
    Http request -> Controller -> Service -> DAO/Repository -> DB
    Iar rezultatul se intoarce invers pana in Controller care il serializeaza in JSON
    -------------
    mvn clean package                   -un fel de rebuild la tot mvn
    docker compose up -d                start database
    docker compose ps                   status
    docker exec -it postgres bash       te duci in folder ala
    psql -U loocos                      intri in baza de date loocos
    \l                                  iti arata ce ai acolo
    \x                                  expanded dispay
    \c customer                         te conectezi la baza de date
    \d                                  arata relatiile
    \dt                                 list of relations
    \dn                                 lista de schema
    \q                                  exit din baza de date
    ctrl + d                            iesi de tot
    --------------
    @Entity - Spune lui JPA/Hibernate ca aceasta clasa este o entitate si trebuie mapata la un tabel din baza de date (numele clasei este numele tabelului cu lowercase)
    @Id - marcheaza campul Id ca fiind primaryKey a tabelului/entitati
    @SequenceGenerator - DefineÈ™te un generator de secvenÈ›Äƒ care va fi folosit pentru a genera valorile cÃ¢mpului id.
                         name â€“ numele generatorului (poÈ›i sÄƒ-l foloseÈ™ti mai jos Ã®n @GeneratedValue).
                         sequenceName â€“ numele secvenÈ›ei din baza de date care va produce valorile numerice (PostgreSQL trebuie sÄƒ aibÄƒ o secvenÈ›Äƒ customer_id_sequence sau Hibernate o va crea dacÄƒ ddl-auto=create).
                         Practic: de fiecare datÄƒ cÃ¢nd inserezi un nou Customer, Hibernate cere urmÄƒtoarea valoare din secvenÈ›Äƒ È™i o foloseÈ™te ca id.
    @GeneratedValue - Spune cum sÄƒ fie generatÄƒ valoarea pentru cÃ¢mpul id.
                      strategy = GenerationType.SEQUENCE â†’ foloseÈ™te o secvenÈ›Äƒ din baza de date.
                      generator = "customer_id_sequence" â†’ foloseÈ™te generatorul de mai sus (@SequenceGenerator).
                      Practic, nu mai trebuie sÄƒ setezi manual id, Hibernate o va popula automat la INSERT.
   --------------
   JDBC - Java Database Connectivity - este API-ul standard din java care iti permite sa te conectezi si sa lucrezi cu baze de date rationale
   In Spring JDBC este stratul de baza folosit pentru comunicarea cu baza de date
   cand eu folosesc customerRepository.save(customer) in spate se intampla asta:
   Spring data JPA - transforma obiectul Customer intr-un querry SQL
   Hibernate - ORM-ul default pentru JAVA - genereaza acel sql efectiv
   Hibernate foloseste JDBC sa trimita acel SQL la baza de date
   Driverul JDBC executa querry pe baza de date si returneaza rezultatele
   ----------------
   Hibernate - este un ORM(Object relational mapping) framework pentru Java
   Transforma obiectele Java (Customer) in randuri din tabelul SQL
   si invers transforma randurile din baza de date in obiecte JAVA

   --------------------
   | Concept         | Ce este (DefiniÈ›ie scurtÄƒ)                                | Ce face (Rolul lui Ã®n aplicaÈ›ie)                                                                         | Exemplu simplu                                                              |
   | --------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
   | **Spring**      | Framework Java pentru aplicaÈ›ii enterprise, modular.      | ÃÈ›i oferÄƒ infrastructura: Dependency Injection (IOC), AOP, configurare uÈ™oarÄƒ.                           | Creezi un `@Service`, Spring se ocupÄƒ sÄƒ Ã®È›i dea instanÈ›a unde ai nevoie.   |
   | **Spring Boot** | Extensie a Spring â†’ face configurarea automatÄƒ È™i rapidÄƒ. | EliminÄƒ fiÈ™iere XML, aduce autoconfigurare, server Tomcat integrat, starter dependencies.                | Rulezi aplicaÈ›ia cu un singur `main()`, fÄƒrÄƒ sÄƒ configurezi server separat. |
   | **Hibernate**   | Framework **ORM** (Object-Relational Mapping).            | LeagÄƒ obiectele Java (`Customer`) de tabele SQL. GenereazÄƒ È™i executÄƒ SQL pentru tine.                   | `customerRepository.save(customer)` â†’ Hibernate face `INSERT` Ã®n DB.        |
   | **JDBC**        | API standard Java pentru conectarea la baze de date.      | Trimite SQL-ul efectiv la DB È™i primeÈ™te rezultatele. Hibernate È™i Spring Boot Ã®l folosesc â€sub capotÄƒâ€. | `DriverManager.getConnection(...)`, `PreparedStatement.executeQuery(...)`.  |
   | **Bean**        | Obiect creat È™i gestionat de containerul Spring.          | Spring Ã®l creeazÄƒ, Ã®l configureazÄƒ È™i Ã®l injecteazÄƒ unde ai nevoie (prin `@Autowired`).                  | `@Bean` Ã®ntr-o clasÄƒ de config sau `@Service` devine bean automat.          |
   | **API**         | InterfaÈ›Äƒ de comunicare Ã®ntre aplicaÈ›ii.                  | Ãn contextul tÄƒu â†’ expui endpoint-uri REST pentru ca altcineva sÄƒ poatÄƒ trimite request-uri HTTP.        | `@GetMapping("/customers")` â†’ returneazÄƒ JSON cu lista de clienÈ›i.          |

Cum lucreazÄƒ Ã®mpreunÄƒ Ã®ntr-o aplicaÈ›ie

ImagineazÄƒ-È›i un flux de POST /customers:

API (Controller): primeÈ™te JSON din Postman â†’ Ã®l transformÄƒ Ã®n obiect CustomerRegistrationRequest.

Spring (Beans & DI): injecteazÄƒ CustomerService Ã®n CustomerController.

Spring Boot: porneÈ™te aplicaÈ›ia cu Tomcat integrat, creeazÄƒ contextul Spring, Ã®ncarcÄƒ toate componentele.

Service + Repository: CustomerService cheamÄƒ customerRepository.save(...).

Hibernate (ORM): genereazÄƒ SQL de tip INSERT pentru obiectul primit.

JDBC: trimite SQL-ul la PostgreSQL.

Baza de date: salveazÄƒ datele, Ã®ntoarce rÄƒspunsul â†’ Hibernate Ã®l transformÄƒ Ã®napoi Ã®n obiect, iar controllerul Ã®l returneazÄƒ ca JSON.

ğŸ”‘ Pe scurt:

Spring = â€scheletulâ€ aplicaÈ›iei tale, cu DI È™i alte features.

Spring Boot = â€boosterulâ€ care face pornirea È™i configurarea super rapidÄƒ.

Hibernate = face legÄƒtura Ã®ntre obiectele tale È™i SQL.

JDBC = executÄƒ SQL-ul real Ã®n DB.

Bean = obiect pe care Spring Ã®l creeazÄƒ È™i Ã®l injecteazÄƒ pentru tine.

API = modul prin care lumea interacÈ›ioneazÄƒ cu aplicaÈ›ia ta (REST endpoints).
-----------
Flyway (sau liquidway) - este un tool de database migration - tine evidenta versiuni de database si aplica automat scripturi pentru a fi la zi
DataSource - este obiectul care stie cum sa creeze si sa ofere conexiuni catre baza de date
In loc sa faci manual connexiuni cu DriverManager.getConnexion(...) el ofera o metoda mai rapida si mai eleganta + connection pooling
-------------
Concept	Se ocupÄƒ deâ€¦	Ce "puleazÄƒ"	Folosit de
HikariCP	Conexiuni la DB	Conexiuni	Spring Data JPA, JdbcTemplate
Tomcat TP	Fire pentru HTTP	Thread-uri	Serverul Tomcat (web requests)
---------------
HikariCP - un connection pool pentru conexiuni la baza de date, gestioneaza conexiunile catre baza de date intr-un mod rapid si eficient
La pornirea aplicatiei, HikariCP deschide un nr de conexiuni la DB, cand aplicatia are nevoie sa ruleze un querry, hicariCP ii da o conexiune din pool.
Cand se termina, conexiunea nu se inchide ci se intoarce in pool, gata pentru urmatorul request

Tomcat Thread Pool - un thread pool(pool de fire de executie) folosit de Tomcat, care e serverul web incorporat in Sprin Boot.
Gestioneaza fierele de executie care raspund la cererile Http(GET/POST/PUT/DELETE)
Cand vine un req de la un client(browser, etc), tomcat ia un thread din pool ca sa proceseze cererea, dupa ce req a fost rezolvat, thread-ul este eliberat si se poate folosi pentru un alt reques
----------
